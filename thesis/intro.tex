\chapter{Introduction}
%\chapter*{Introduction}
%\addcontentsline{toc}{chapter}{Introduction}

\section{GADTs}

Algebraic Data Types are recursive sum types \cite{?}. An ADT is a type whose values can be one of some predefined variants (called \textit{constructors}). They are, however, more powerful than just enumeration types, because each variant can hold additional data within it. As the type is recursive, the data held by each constructor can also have the ADT type. Moreover, they usually can be parametric (that is, the ADT can be parametrized by type arguments).

A classic example of an ADT are the Option and List types:

\begin{verbatim}
enum Option[T]:
  case Some(x: T)
  case None
\end{verbatim}

The \texttt{Option} type is parametrized by a single type parameter \texttt{T}\footnote{In practice, in Scala, we would write \texttt{Option[+T]} to indicate that the type is covariant in \texttt{T}, however my work mostly focuses on invariant GADTs, so for simplicity I omit this detail.} (indicating the type of element held by it) and has two constructors: \texttt{Some} containing some data of type \texttt{T} and \texttt{None} indicating that the value was empty.

\begin{verbatim}
enum List[T]:
  case Cons(head: T, tail: List[T])
  case Nil
\end{verbatim}

The \texttt{List} type is also parametrized by the type of elements that will be held on the list and has two constructors: \texttt{Nil} indicating an empty list and \texttt{Cons} which holds a single element (the list's head) and a reference to the tail of the list (which can contain more elements or be empty).

Generalized Algebraic Data Types extend ADTs with existential types and type constraints. The difference between ADTs and GADTs is that the latter allow to have \textit{additional} type parameters for each constructor and allow to instantiate the type parameters of the type itself to specific values. To express this, Scala 3 uses the \texttt{extends} syntax which allows to specifically instantiate the type parameters.

For example, going back to the \texttt{Option} example, we could have written:

\begin{verbatim}
enum Option[T]:
  case Some(x: T) extends Option[T]
  case None extends Option[T]
\end{verbatim}

The above more clearly shows that both \texttt{Some} and \texttt{None} are constructors which take one or zero arguments and create an instance of \texttt{Option[T]}. Usually this is omitted for conciseness in case of simple ADTs, as the compiler can infer that. However in case of GADTs we may instantiate these arguments to more specific values, for example:

\begin{verbatim}
enum Expr[T]:
  case IntLiteral(value: Int) extends Expr[Int]
  case StringLiteral(value: Int) extends Expr[String]
  case Plus(lhs: Expr[Int], rhs: Expr[Int])
  case Concat(lhs: Expr[String], rhs: Expr[String])
  case Pair[A, B](lhs: Expr[A], rhs: Expr[B]) extends Expr[(A, B)]
\end{verbatim}

The above is a classic example of an application of ADTs - we can create a type-safe expression type that allows us to build expressions operating on integers, strings and pairs of data and will not allow to build an expression that does not typecheck.

A variant without GADTs would not be able to enforce that the \texttt{Plus} operation can only take expressions returning an integer at compile time:

\begin{verbatim}
enum Expr:
  case IntLiteral(value: Int)
  case StringLiteral(value: Int)
  case Plus(lhs: Expr, rhs: Expr)
  case Concat(lhs: Expr, rhs: Expr)
  case Pair(lhs: Expr, rhs: Expr)
  
// Would compile but is ill-formed
Plus(IntLiteral(42), StringLiteral("foo"))
\end{verbatim}

The \texttt{Expr} example will be used many times throughout this work (often in a slightly thinned down version) as it shows all the features of GADTs.

It is a sum type with 5 variants. Its constructors instantiate the type parameter to specific values and the \texttt{Pair} constructor exhibits existential types.

To show the usefulness of this kind of an encoding, we can write a type-safe interpreter of these expressions:

\begin{verbatim}
def eval[A](expr: Expr[A]): A = expr match {
  case IntLiteral(x) => x
  case StringLiteral(s) => s
  case Plus(lhs, rhs) => 
    val l: Int = eval(lhs)
    val r: Int = eval(rhs)
    l + r
  case Concat(lhs, rhs) =>
    val l: String = eval(lhs)
    val r: String = eval(rhs)
    l + r
  case Pair[X, Y](lhs, rhs) =>
    val l: X = eval(lhs)
    val r: Y = eval(rhs)
    (l, r)
}
\end{verbatim}

The nice thing about the above interpreter is that it is able to specify in its function type that for an expression of type \texttt{Expr[A]} it will return an evaluated value of type \texttt{A}. Moreover, by the construction of the \texttt{Expr} type, it will only take valid expressions, so there is no possibility of a runtime type error - it is impossible to construct, for example an expression that adds a string to an integer using this model.

A very important feature of GADTs is that the compiler can use the additional information about particular constructors and how they instantiate the type parameters to infer some additional type constraints which can be used during typechecking. We can see them on the above example:

\begin{itemize}
  \item The \texttt{IntLiteral} branch returns \texttt{x} which has type \texttt{Int}, but since we have deconstructed \texttt{expr} and know that it has been created using the \texttt{IntLiteral} constructor, which always instantiates the type parameter to \texttt{Int}, the compiler can infer a type constraint \texttt{A =:= Int} and thus the branch type-checks, because it returns an \texttt{Int} where a value of type \texttt{A} is expected, but we know that they are of the same type.
  
  \item The \texttt{Plus} branch works in a similar way - its data members \texttt{lhs} and \texttt{rhs} are of type \texttt{Expr[Int]} so the recursive invocations of \texttt{eval} return \texttt{Int}s too and the overall operation returns \texttt{Int} where \texttt{A} is expected, but since we know that in this case \texttt{expr} was created using the \texttt{Plus} constructor, again we get a constraint proving that \texttt{A =:= Int}.
  
  \item The \texttt{Pair} branch is more interesting because it also features the existential types - when we enter this branch, types \texttt{X} and \texttt{Y} enter the scope. We know that \texttt{expr} has been created using the \texttt{Pair} constructors which was provided with some two types, we do not know anything about them, but can refer to them by the bound names\footnote{This is very similar to existential quantification in logic, where in the expresssion $\exists_x. P(x)$ we know that we have $P(x)$ for some element $x$, but we do not know anything else about this element, the only thing that we can do is we can give it a name, for example $e$ and we will know from the predicate that $P(e)$ holds.}. From the constructor that was used, we know that \texttt{A} was instantiated to \texttt{(X, Y)}, so we get a constraint \texttt{A =:= (X, Y)}. As \texttt{lhs} has type \texttt{Expr[X]}, \texttt{eval(lhs)} will have type \texttt{X} and analogously for \texttt{rhs}, so then \texttt{(l, r)} has type \texttt{(X, Y)} and everything type-checks.
\end{itemize}

The above example shows that the real power of GADTs lies not only in allowing to restrict what kinds of structures can be created using the constructors, but also in allowing the compiler to perform more advanced type equality reasoning when pattern matching these types.

\section{GADTs in Scala}

GADTs have already been available in Scala 2, although there was no special syntax for defining a GADT. Instead, they were emulated using \textit{sealed traits} and \textit{case classes}.

We can take a simplified example from the previous section (we will often use it in this simplified form from now on) in Scala 3 syntax:

\begin{verbatim}
enum Expr[T]:
  case IntLiteral(value: Int) extends Expr[Int]
  case Plus(lhs: Expr[Int], rhs: Expr[Int])
  case Pair[A, B](lhs: Expr[A], rhs: Expr[B]) extends Expr[(A, B)]
\end{verbatim}

The analogous construction in Scala 2 would be following:

\begin{verbatim}
sealed trait Expr[T]
object Expr {
  case class IntLiteral(value: Int) extends Expr[Int]
  case class Plus(lhs: Expr[Int], rhs: Expr[Int]) extends Expr[Int]
  case class Pair[A, B](lhs: Expr[A], rhs: Expr[B]) extends Expr[(A, B)]
}
\end{verbatim}

In fact, the \texttt{enum} syntactic sugar of Scala 3 desugars to a class hierarchy that very closely resembles the above definition.

Unfortunately, the type inference of GADTs in Scala 2 was plagued with soundness issues \cite{Towards}. \todo{Maybe look for a concrete example and show it here?}

Scala 3 has been built on new, sound, type-theoretic foundations, the calculus of Dependent Object Types \cite{EssenceDOT}. The redesign of the language involved removing some of its features to make the language more consistent and sound \todo{Probably worth listing these features}. The new type inference is designed to more closely resemble the foundational calculus which should give more assurance that such type inference is sound.

To better understand the GADT reasoning in context of Scala's calculus and guide the implementation of type inference, a sketch of encoding GADTs using simpler Scala constructs has been proposed \cite{Towards}. I have then refined this sketch and proposed an encoding \cite{myreport:277075} \todo{not sure if I should cite this, as the report's name is the same as the thesis which may look strange?} of a lambda calculus containing GADTs into pDOT (an extension of DOT, \cite{pDOT}). Part of this work is an attempt to further formalize this encoding.

\section{Practical Example}

To further advertise the usefulness of GADTs, I show an example of production code using GADTs to get better invariants at the typelevel for something very practical - configuration of a logging service\footnote{The code is adapted from the logging service of the Enso engine, available at https://github.com/enso-org/enso/blob/746521f8b20de95f4300fb950207c12c8ee687c0/lib/scala/logging-service/src/main/scala/org/enso/loggingservice/LoggerMode.scala under the Apache 2.0 license; copyright New Byte Order sp. z o.o.}.

The logging service can run in three different modes: Local mode which just prints logs to the standard output or some files, Client mode which forwards the logs to a server and Server mode which can gather logs from the clients and its own instance and print them, aggregated, in a similar way to the Local mode.

The configuration like above can be easily modeled with a simple ADT, but GADTs allow us to do something even better. When we initialize the service in Client or Local mode, we just want to know that it has been initialized and there is no other data that should be returned. However, when we initialize it in Server mode, the system automatically allocates a free port and we need to know which port was chosen so that it can later be passed on to the clients. This is where the instantiation of type parameters in GADTs can help us - we parametrize the configuration with a single type parameter - \texttt{InitializationResult}. The parameter is instantiated to \texttt{Unit} for Local and Client modes, however for the Server mode it is instantiated to a \texttt{ServerBinding} type that can be used to tell the clients how to connect to the service.

This leads us to the following definition of the configuration:

\begin{verbatim}
sealed trait LoggerMode[InitializationResult]
object LoggerMode {
  case class Client(endpoint: Uri) extends LoggerMode[Unit]
  case class Server(
    printers: Seq[Printer], 
    port: Option[Int] = None, 
    interface: String = "localhost") extends LoggerMode[ServerBinding]
  case class Local(printers: Seq[Printer]) extends LoggerMode[Unit]
}
\end{verbatim}

Now, when writing the code to initialize the service, we can parametrize the initializer function so that it will return the \texttt{InitializationResult} based on the chosen mode\footnote{The implementation below has been simplified from the actual implementation for conciseness, but the GADT related logic has been kept in a very similar manner.}.

\begin{verbatim}
object LoggingServiceManager {
  def setup[InitializationResult](mode: LoggerMode[InitializationResult])
    : Future[InitializationResult] = Future {
      mode match {
        case Local(printers) =>
          setupLocal(printers) : Unit
        case Client(uri) =>
          connectToServer(uri) : Unit
        case Server(printers, port, interface) =>
          val server = new Server(printers, port, interface)
          server.start()
          server.getBindings : ServerBinding
      }
    }
    
}
\end{verbatim}

So that if the user wants to just run the service in client mode, they will just get a future that completes with an `empty' (\texttt{Unit}) value, which will indicate that the initialization has completed:

\begin{verbatim}
val config = LoggerMode.Client("ws://localhost:1234/")
LoggingServiceManager.setup(config) : Future[Unit]
\end{verbatim}

However, if the client wants to set up a server, once the initialization is complete, they will get the \texttt{ServerBinding} which they can pass to the clients:

\begin{verbatim}
val config = LoggerMode.Server(Seq(new StdOutPrinter))
val init: Future[ServerBinding] = LoggingServiceManager.setup(config)
init.onComplete { binding: ServerBinding =>
  for (client <- clients) {
    client.informAboutServer(binding)
  }
}
\end{verbatim}

\section{Describe the work done}

TODO the formalization and encoding sketch; this should probably be done later when I know precisely what is and is not done
